{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Geometric objects - Spatial data model\n",
    "\n",
    "**Sources:**\n",
    "\n",
    "These materials are partly based on [Shapely-documentation](http://toblerity.org/shapely/manual.html) and [Westra\n",
    "E. (2013), Chapter 3](https://www.packtpub.com/application-development/python-geospatial-development-second-edition).\n",
    "\n",
    "## Overview of geometric objects and Shapely -module\n",
    "\n",
    "![Spatial data model](http://www.helsinki.fi/science/accessibility/maintenance/Kuvia/SpatialDataModel.PNG)\n",
    "*Fundamental geometric objects that can be used in Python with* [Shapely](http://toblerity.org/shapely/manual.html) *module*\n",
    "\n",
    "The most fundamental geometric objects are `Points`, `Lines` and `Polygons` which are the basic ingredients when working with spatial data in vector format. Python has a specific module called [Shapely](http://toblerity.org/shapely/manual.html) that can be used to create and work with `Geometric Objects`. There are many useful functionalities that you can do with Shapely such as:\n",
    "\n",
    "-  Create a `Line` or `Polygon` from a `Collection` of `Point` -geometries\n",
    "-  Calculate areas/length/bounds etc. of input geometries\n",
    "-  Conduct geometric operations based on the input geometries such as `Union`, `Difference`, `Distance` etc.\n",
    "-  Conduct spatial queries between geometries such `Intersects`, `Touches`, `Crosses`, `Within` etc.\n",
    "\n",
    "**Geometric Objects consist of coordinate tuples where:**\n",
    "\n",
    "-  `Point` -object represents a single point in space. Points can be either two-dimensional (x, y) or three dimensional (x, y, z).\n",
    "-  `LineString` -object (i.e. a line) represents a sequence of points joined together to form a line. Hence, a line consist of a list of at least two coordinate tuples\n",
    "-  `Polygon` -object represents a filled area that consists of a list of at least three coordinate tuples that forms the outerior ring and a (possible) list of hole polygons.\n",
    "\n",
    "**It is also possible to have a collection of geometric objects (e.g. Polygons with multiple parts):**\n",
    "\n",
    "-  `MultiPoint` -object represents a collection of points and consists of a list of coordinate-tuples\n",
    "-  `MultiLineString` -object represents a collection of lines and consists of a list of line-like sequences\n",
    "-  `MultiPolygon` -object represents a collection of polygons that consists of a list of polygon-like sequences that construct from exterior ring and (possible) hole list tuples\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Point\n",
    "\n",
    "-  Creating point is easy, you pass x and y coordinates into `Point()` -object (+ possibly also z -coordinate):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Import necessary geometric objects from shapely module\n",
    "from shapely.geometry import Point, LineString, Polygon\n",
    "\n",
    "# Create Point geometric object(s) with coordinates\n",
    "point1 = Point(2.2, 4.2)\n",
    "point2 = Point(7.2, -25.1)\n",
    "point3 = Point(9.26, -2.456)\n",
    "point3D = Point(9.26, -2.456, 0.57)\n",
    "\n",
    "# What is the type of the point?\n",
    "point_type = type(point1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "-  Let's see what the variables look like"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "POINT (2.2 4.2)\n",
      "POINT Z (9.26 -2.456 0.57)\n",
      "<class 'shapely.geometry.point.Point'>\n"
     ]
    }
   ],
   "source": [
    "print(point1)\n",
    "print(point3D)\n",
    "print(type(point1))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can see that the type of the point is shapely's Point which is represented in a specific format that is based on\n",
    "[GEOS](https://trac.osgeo.org/geos) C++ library that is one of the standard libraries in GIS. It runs under the hood e.g. in [QGIS](http://www.qgis.org/en/site/). 3D-point can be recognized from the capital Z -letter in front of the coordinates."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Point attributes and functions\n",
    "\n",
    "Point -object has some built-in attributes that can be accessed and also some useful functionalities. One of the most useful ones are the ability to extract the coordinates of a Point and calculate the Euclidian distance between points.\n",
    "\n",
    "-  Extracting the coordinates of a Point can be done in a couple of different ways:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "shapely.coords.CoordinateSequence"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Get the coordinates\n",
    "point_coords = point1.coords\n",
    "\n",
    "# What is the type of this?\n",
    "type(point_coords)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see, the data type of our `point_coords` variable is a Shapely CoordinateSequence.\n",
    "\n",
    "- Let's see how we can get out the actual coordinates from this object:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "xy variable:\n",
      " (array('d', [2.2]), array('d', [4.2])) \n",
      "\n",
      "x variable:\n",
      " 2.2 \n",
      "\n",
      "y variable:\n",
      " 4.2\n"
     ]
    }
   ],
   "source": [
    "# Get x and y coordinates\n",
    "xy = point_coords.xy\n",
    "\n",
    "# Get only x coordinates of Point1\n",
    "x = point1.x\n",
    "\n",
    "# Whatabout y coordinate?\n",
    "y = point1.y\n",
    "\n",
    "# Print out\n",
    "print(\"xy variable:\\n\", xy, \"\\n\")\n",
    "print(\"x variable:\\n\", x, \"\\n\")\n",
    "print(\"y variable:\\n\", y)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see from above the `xy` -variable contains a tuple where x and y coordinates are stored inside numpy arrays.\n",
    "Using the attributes `point1.x` and `point1.y` it is possible to get the coordinates directly as plain decimal numbers.\n",
    "\n",
    "-  It is also possible to calculate the distance between points which can be useful in many applications. The returned distance is based on the projection of the points (e.g. degrees in WGS84, meters in UTM):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Distance between the points is 29.72 decimal degrees\n"
     ]
    }
   ],
   "source": [
    "# Calculate the distance between point1 and point2\n",
    "point_dist = point1.distance(point2)\n",
    "\n",
    "print(\"Distance between the points is {0:.2f} decimal degrees\".format(point_dist))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
